--
-- Autogenerated by Thrift
--
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
-- @generated
--


require 'Thrift'
require 'alchemy_constants'

C2SAlchemyCompose = __TObject:new{
  formulaConfigId
}

function C2SAlchemyCompose:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.formulaConfigId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function C2SAlchemyCompose:write(oprot)
  oprot:writeStructBegin('C2SAlchemyCompose')
  if self.formulaConfigId then
    oprot:writeFieldBegin('formulaConfigId', TType.STRING, 1)
    oprot:writeString(self.formulaConfigId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

S2CAlchemyCompose = __TObject:new{
  addItems,
  removeItems,
  curGold
}

function S2CAlchemyCompose:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.LIST then
        self.addItems = {}
        local _etype3, _size0 = iprot:readListBegin()
        for _i=1,_size0 do
          local _elem4 = ItemDTO:new{}
          _elem4:read(iprot)
          table.insert(self.addItems, _elem4)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.removeItems = {}
        local _etype8, _size5 = iprot:readListBegin()
        for _i=1,_size5 do
          local _elem9 = ItemDTO:new{}
          _elem9:read(iprot)
          table.insert(self.removeItems, _elem9)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.curGold = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function S2CAlchemyCompose:write(oprot)
  oprot:writeStructBegin('S2CAlchemyCompose')
  if self.addItems then
    oprot:writeFieldBegin('addItems', TType.LIST, 1)
    oprot:writeListBegin(TType.STRUCT, #self.addItems)
    for _,iter10 in ipairs(self.addItems) do
      iter10:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.removeItems then
    oprot:writeFieldBegin('removeItems', TType.LIST, 2)
    oprot:writeListBegin(TType.STRUCT, #self.removeItems)
    for _,iter11 in ipairs(self.removeItems) do
      iter11:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.curGold then
    oprot:writeFieldBegin('curGold', TType.I32, 3)
    oprot:writeI32(self.curGold)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

C2SAlchemyDecompose = __TObject:new{
  formulaConfigId
}

function C2SAlchemyDecompose:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.formulaConfigId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function C2SAlchemyDecompose:write(oprot)
  oprot:writeStructBegin('C2SAlchemyDecompose')
  if self.formulaConfigId then
    oprot:writeFieldBegin('formulaConfigId', TType.STRING, 1)
    oprot:writeString(self.formulaConfigId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

S2CAlchemyDecompose = __TObject:new{
  addItems,
  removeItems
}

function S2CAlchemyDecompose:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.LIST then
        self.addItems = {}
        local _etype15, _size12 = iprot:readListBegin()
        for _i=1,_size12 do
          local _elem16 = ItemDTO:new{}
          _elem16:read(iprot)
          table.insert(self.addItems, _elem16)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.removeItems = {}
        local _etype20, _size17 = iprot:readListBegin()
        for _i=1,_size17 do
          local _elem21 = ItemDTO:new{}
          _elem21:read(iprot)
          table.insert(self.removeItems, _elem21)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function S2CAlchemyDecompose:write(oprot)
  oprot:writeStructBegin('S2CAlchemyDecompose')
  if self.addItems then
    oprot:writeFieldBegin('addItems', TType.LIST, 1)
    oprot:writeListBegin(TType.STRUCT, #self.addItems)
    for _,iter22 in ipairs(self.addItems) do
      iter22:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.removeItems then
    oprot:writeFieldBegin('removeItems', TType.LIST, 2)
    oprot:writeListBegin(TType.STRUCT, #self.removeItems)
    for _,iter23 in ipairs(self.removeItems) do
      iter23:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end